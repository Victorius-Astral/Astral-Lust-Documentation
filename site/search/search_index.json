{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Astral Lust Documentation Ren\u2019Py and Python Ren\u2019Py documentation Python documentation Python tutorial / code usage & examples Astral Lust Modding Cards Dreams Enemies","title":"Home"},{"location":"#astral-lust-documentation","text":"","title":"Astral Lust Documentation"},{"location":"#renpy-and-python","text":"Ren\u2019Py documentation Python documentation Python tutorial / code usage & examples","title":"Ren'Py and Python"},{"location":"#astral-lust-modding","text":"Cards Dreams Enemies","title":"Astral Lust Modding"},{"location":"cards/","text":"Cards Add new cards To add new cards you need to create your cards as a class being a child of Card class. Action to be done on card use is to be contained in play() method. class Take_Cover(Card): def __init__(self): # card name / .webp image name self.name = \"Take Cover\" # spirituality cost self.sp = 2 # category: Offensive, Defensive, Ability, Power, Tarot self.ca = \"Defensive\" # rarity: Ordinary, Extraordinary, Mythical, Angelic, Divine, Unique, Tarot self.ra = \"Extraordinary\" # Help to be displayed when card is hovered self.tip = '> Block:\\n'+str(player.eff['Block'][1])+'\\n\\n> Dodge:\\n' + str(player.eff['Dodge'][1]) def play(self, **kwargs): self.block(amt = 10, target = player) self.dodge(amt = 10, target = player) return Cards Images Start by either creating your own or downloading vanilla card templates: PNG WebP When using my template you should: Put card art behind the template (so it\u2019s visible in the middle) Name the card at the top Define card spirit cost to the right of card name Choose correct card rarity & type from templates Describe it\u2019s effects below card type Cards need to be: Named like the card name attribute Placed in AstralLust\\game\\images\\Cards\\ directory Saved in .webp format, I recommend using Bulk Images to WebP Converter for Chrome with 95% quality Resolution should follow: 13:20 proportions. Default resolution for 4K is 650x1000, for 1080p 325x500. It\u2019s not recommended to make cards above 4K default resolution for optimization reasons. You don\u2019t need to make two sets of cards for 4K and 1080p, but low res cards will help optimization. You can make cards in any image editor like paint, paint.net, gimp, photoshoot, etc. Status Effects Status effects are granted using buff(), it takes three arguments: buff - required, name of status effect - string, amt - required, status effect will be changed by this amount - depends on buff, either integer or boolean, minus - if status effect can take negative value - boolean, default True def play(self, **kwargs): player.buff(\"Fire Immunity\", True) enemy.buff(\"Ressurect\", 1) return Exhaust and Destroy Cards can be destroyed with self.destroy() . To exhaust a card you need to return \u201cexhaust\u201d with play() . Take note that destroy() removes card from your deck not hand/any pile, to make card dissapear from combat return \"exhaust\" . def play(self, **kwargs): ... card action ... self.destroy() return \"exhaust\" X card cost Set card cost to 0 and execute your action x times, at the end set player.spirit to 0: def play(self, **kwargs): # Attack x times self.atk(dmg = 4, target = enemy, times = player.spirit) # Do something x times for x in range(player.spirit): ... action ... # Set player spirit to 0 player.spirit = 0 return Complex Effects Returning \u201ccomplex\u201d with play() will skip using card cost and removing it from hand, it can be used with complex card effects that move/exhaust the card before return statement. Other Card class methods draw() - draw x cards: amt - required, amount of cards to draw min - minimum amount of cards to draw, default 0 discard - if discard hand before drawing cards, default False skip_discarded - if skip shuffling discard pile into draw pile if not enough cards, default True steal() - steal enemy status effects: times - how many effects to steal, default 1 enemy_intention() - change enemy intention List of all status effects Integer: Armor -Each turn increase block by x. Critic - Increase next damage dealt multiplied x times. Bleeding - Each turn deals x damage. Damage doubled if target has Frail. Decreases by 1 every turn. Block - Block up to x points of damage. Lasts till next turn. Dodge - Gives x% to avoid damage. Lasts till next turn. Dodge chance capped at 80%. Burning - Each turn deals 5 damage. Lasts x turns. Frail - Gain x less block. Decreases by 1 every turn. Invulnerability - Become immune to all damage. Lasts x turns. Life Steal - Heal for x% damage dealt. Poison - Each turn deals x damage. Damage doubled if target is bleeding. Decreases by 1 every turn. Regeneration - Each turn heals x health. Decreases by 1 after taking damage. Resurrect - Will resurrect with 50% of health after death. Strength - Deal x more damage. Decreases by 1 every turn. Stun - Unable to act for x turns. Thorns - Deal x before being attacked. Lasts till next turn. Weak - Deal 50% less damage. Lasts x turns. Vulnerable - Receive 50% more damage. Lasts x turns. Empower - Gain x strength every turn. Card Draw - Draw x more cards each turn. Clarity - Gain x spirituality each turn. Forbid Offensive - Can\u2019t play offensive cards for x turns. Forbid Defensive - Can\u2019t play defensive cards for x turns. Forbid Ability - Can\u2019t play ability cards for x turns. Forbid Power - Can\u2019t play power cards for x turns. Stealth - Gain x% dodge each turn. Spikes - Gain x thorns every turn. Forbid Tarot - Can\u2019t play tarot cards for x turns. Boolean: Fire Immunity - Immune to burning. Poison Immunity - Immune to poison. Bleeding Immunity - Immune to bleeding. Freedom - Free from corruption and madness.","title":"Cards"},{"location":"cards/#cards","text":"","title":"Cards"},{"location":"cards/#add-new-cards","text":"To add new cards you need to create your cards as a class being a child of Card class. Action to be done on card use is to be contained in play() method. class Take_Cover(Card): def __init__(self): # card name / .webp image name self.name = \"Take Cover\" # spirituality cost self.sp = 2 # category: Offensive, Defensive, Ability, Power, Tarot self.ca = \"Defensive\" # rarity: Ordinary, Extraordinary, Mythical, Angelic, Divine, Unique, Tarot self.ra = \"Extraordinary\" # Help to be displayed when card is hovered self.tip = '> Block:\\n'+str(player.eff['Block'][1])+'\\n\\n> Dodge:\\n' + str(player.eff['Dodge'][1]) def play(self, **kwargs): self.block(amt = 10, target = player) self.dodge(amt = 10, target = player) return","title":"Add new cards"},{"location":"cards/#cards-images","text":"Start by either creating your own or downloading vanilla card templates: PNG WebP When using my template you should: Put card art behind the template (so it\u2019s visible in the middle) Name the card at the top Define card spirit cost to the right of card name Choose correct card rarity & type from templates Describe it\u2019s effects below card type Cards need to be: Named like the card name attribute Placed in AstralLust\\game\\images\\Cards\\ directory Saved in .webp format, I recommend using Bulk Images to WebP Converter for Chrome with 95% quality Resolution should follow: 13:20 proportions. Default resolution for 4K is 650x1000, for 1080p 325x500. It\u2019s not recommended to make cards above 4K default resolution for optimization reasons. You don\u2019t need to make two sets of cards for 4K and 1080p, but low res cards will help optimization. You can make cards in any image editor like paint, paint.net, gimp, photoshoot, etc.","title":"Cards Images"},{"location":"cards/#status-effects","text":"Status effects are granted using buff(), it takes three arguments: buff - required, name of status effect - string, amt - required, status effect will be changed by this amount - depends on buff, either integer or boolean, minus - if status effect can take negative value - boolean, default True def play(self, **kwargs): player.buff(\"Fire Immunity\", True) enemy.buff(\"Ressurect\", 1) return","title":"Status Effects"},{"location":"cards/#exhaust-and-destroy","text":"Cards can be destroyed with self.destroy() . To exhaust a card you need to return \u201cexhaust\u201d with play() . Take note that destroy() removes card from your deck not hand/any pile, to make card dissapear from combat return \"exhaust\" . def play(self, **kwargs): ... card action ... self.destroy() return \"exhaust\"","title":"Exhaust and Destroy"},{"location":"cards/#x-card-cost","text":"Set card cost to 0 and execute your action x times, at the end set player.spirit to 0: def play(self, **kwargs): # Attack x times self.atk(dmg = 4, target = enemy, times = player.spirit) # Do something x times for x in range(player.spirit): ... action ... # Set player spirit to 0 player.spirit = 0 return","title":"X card cost"},{"location":"cards/#complex-effects","text":"Returning \u201ccomplex\u201d with play() will skip using card cost and removing it from hand, it can be used with complex card effects that move/exhaust the card before return statement.","title":"Complex Effects"},{"location":"cards/#other-card-class-methods","text":"draw() - draw x cards: amt - required, amount of cards to draw min - minimum amount of cards to draw, default 0 discard - if discard hand before drawing cards, default False skip_discarded - if skip shuffling discard pile into draw pile if not enough cards, default True steal() - steal enemy status effects: times - how many effects to steal, default 1 enemy_intention() - change enemy intention","title":"Other Card class methods"},{"location":"cards/#list-of-all-status-effects","text":"Integer: Armor -Each turn increase block by x. Critic - Increase next damage dealt multiplied x times. Bleeding - Each turn deals x damage. Damage doubled if target has Frail. Decreases by 1 every turn. Block - Block up to x points of damage. Lasts till next turn. Dodge - Gives x% to avoid damage. Lasts till next turn. Dodge chance capped at 80%. Burning - Each turn deals 5 damage. Lasts x turns. Frail - Gain x less block. Decreases by 1 every turn. Invulnerability - Become immune to all damage. Lasts x turns. Life Steal - Heal for x% damage dealt. Poison - Each turn deals x damage. Damage doubled if target is bleeding. Decreases by 1 every turn. Regeneration - Each turn heals x health. Decreases by 1 after taking damage. Resurrect - Will resurrect with 50% of health after death. Strength - Deal x more damage. Decreases by 1 every turn. Stun - Unable to act for x turns. Thorns - Deal x before being attacked. Lasts till next turn. Weak - Deal 50% less damage. Lasts x turns. Vulnerable - Receive 50% more damage. Lasts x turns. Empower - Gain x strength every turn. Card Draw - Draw x more cards each turn. Clarity - Gain x spirituality each turn. Forbid Offensive - Can\u2019t play offensive cards for x turns. Forbid Defensive - Can\u2019t play defensive cards for x turns. Forbid Ability - Can\u2019t play ability cards for x turns. Forbid Power - Can\u2019t play power cards for x turns. Stealth - Gain x% dodge each turn. Spikes - Gain x thorns every turn. Forbid Tarot - Can\u2019t play tarot cards for x turns. Boolean: Fire Immunity - Immune to burning. Poison Immunity - Immune to poison. Bleeding Immunity - Immune to bleeding. Freedom - Free from corruption and madness.","title":"List of all status effects"},{"location":"dreams/","text":"Dreams Add new dreams Create new label consisting of three parts: prefix d_ - That\u2019s required for dream to be recognize as a dream name My_Dream_Name - Name of your dream, replace spaces with _ suffix _type - Category of your dream: 0 - Normal / Positive - brings positive or no effect 1 - Nightmare - brings negative effect 2 - Wet - contains H scenes 3 - Other - special or complex effects, can\u2019t be put in other category Code should look like this: label d_Light_0: scene d 2 1 with fade \"You open your eyes only to see a light.\" \"The light illuminates the world.\" \"You float amidst the clouds and enjoy the light shining on you.\" $player.corrupt(-3) \"You fell purified.\" jump d_end More label examples: label d_First_Love_2: label d_Deal_with_the_Devil_3: label d_Reccuring_Nightmare_1: Dreams should be ended with jump d_end - it\u2019s a generic dream ending it blackens the screen and executes sleep method, you can end the dream other way if you know what you are doing: label d_end: # Start to make the screen fade to darkness show screen blacken(ilosc = \"50\") with dissolve \"You feel everything around fading away. You are awakening.\" pause 0.25 show screen blacken(ilosc = \"90\") with dissolve pause 0.25 show screen blacken(ilosc = \"C0\") with dissolve pause 0.25 show screen blacken(ilosc = \"FF\") with dissolve pause 0.25 # Restore player hp & sanity $player.sleep() # Stop all music and sound from dream stop music2 fadeout 1.0 stop sound fadeout 1.0 stop music fadeout 1.0 # Play music depending on location if \"room_hotel\" in player.location: play music persistent.music_hotel fadein 1.0 # Return to the label return Change dream chance To change the base dreams chance you need to change dream_base_chance variable, like this: init 11 python: # Float, 1.0 for 100% chance, 0.0 for 0% chance. dream_base_chance = 0.4","title":"Dreams"},{"location":"dreams/#dreams","text":"","title":"Dreams"},{"location":"dreams/#add-new-dreams","text":"Create new label consisting of three parts: prefix d_ - That\u2019s required for dream to be recognize as a dream name My_Dream_Name - Name of your dream, replace spaces with _ suffix _type - Category of your dream: 0 - Normal / Positive - brings positive or no effect 1 - Nightmare - brings negative effect 2 - Wet - contains H scenes 3 - Other - special or complex effects, can\u2019t be put in other category Code should look like this: label d_Light_0: scene d 2 1 with fade \"You open your eyes only to see a light.\" \"The light illuminates the world.\" \"You float amidst the clouds and enjoy the light shining on you.\" $player.corrupt(-3) \"You fell purified.\" jump d_end More label examples: label d_First_Love_2: label d_Deal_with_the_Devil_3: label d_Reccuring_Nightmare_1: Dreams should be ended with jump d_end - it\u2019s a generic dream ending it blackens the screen and executes sleep method, you can end the dream other way if you know what you are doing: label d_end: # Start to make the screen fade to darkness show screen blacken(ilosc = \"50\") with dissolve \"You feel everything around fading away. You are awakening.\" pause 0.25 show screen blacken(ilosc = \"90\") with dissolve pause 0.25 show screen blacken(ilosc = \"C0\") with dissolve pause 0.25 show screen blacken(ilosc = \"FF\") with dissolve pause 0.25 # Restore player hp & sanity $player.sleep() # Stop all music and sound from dream stop music2 fadeout 1.0 stop sound fadeout 1.0 stop music fadeout 1.0 # Play music depending on location if \"room_hotel\" in player.location: play music persistent.music_hotel fadein 1.0 # Return to the label return","title":"Add new dreams"},{"location":"dreams/#change-dream-chance","text":"To change the base dreams chance you need to change dream_base_chance variable, like this: init 11 python: # Float, 1.0 for 100% chance, 0.0 for 0% chance. dream_base_chance = 0.4","title":"Change dream chance"},{"location":"enemies/","text":"Enemies Create new enemy class Werewolf(Enemy): def __init__(self, name = \"Werewolf\", hp = 180, hp_max = 180, po = 1, race = \"Beast\", poU = 0, poL = 0, img = \"WerewolfA\", loot = \"werewolf\", faction = \"None\", act = 1, str = 0, agi = 0, vit = 0, inte = 0, cha = 0, wis = 0, drop = \"werewolf\"): self.name = name self.hp = hp self.hp_max = hp_max self.po = po # power self.race = race self.eff = copy.deepcopy(being.eff) # List of effect one can get in battle self.poU = poU # upper value of power difference ( set both poU and poL to 0 to delete random effects values ) self.poL = poL # lower value of power difference self.img = img # Name of enemy .webp inside Enemy folder self.loot = loot # Lootlist self.faction = faction # Enemy faction self.act = act # Action enemy would do in next turn self.drop = drop # your droplist # Cooldown for actions self.cd = { 1: 0, 2: 0, 3: 0, 4: 0 } # These are added for compatibility, they do nothing for now self.strength = str self.agility = agi self.vitality = vit self.wisdom = wis self.intellect = inte self.charisma = cha self.spirit_max = 0 def action(self, **kwargs): global enemy_state note = \"\" avoid = [] if self.eff['Stun'][0] > 0: self.eff['Stun'][0] -= 1 note = self.name + \" is stunned.\" self.end(note = note) return if self.act == 1: ### Basic Action enemy_state = \"attack\" self.atk(dmg = 14) note = \" slashes you!\" elif self.act == 2: ### 2nd Action self.heal(amt = 25) note = \"'s injuries heal quickly.\" self.cold(2) elif self.act == 3: enemy_state = \"attack\" self.atk(dmg = 6, times = 3) player.buff(\"Bleeding\", 3) note = \" quickly slashes you three times!\" self.cold(2) elif self.act == 4: enemy_state = \"specialA\" self.buff(\"Regeneration\", 4) self.buff(\"Strength\", 5) self.buff(\"Block\", 10) note = \" howls making it even more powerful!\" self.cold(3) if note != \"\": note = self.name + note if self.hp > (self.hp_max - 25): avoid.append(2) self.end(note = note, avoid = avoid) return def intent(self): back = self.name + \" wants to \" if self.act == 1: return back + \"attack.\" elif self.act == 2: if self.hp > (self.hp_max) - 25: return back + \"attack.\" else: return back + \"heal.\" elif self.act == 3: return back + \"rip you apart!\" elif self.act == 4: return back + \"empower itself.\" else: return \"Error 002 - Enemy action outside of possible action list.\" Add enemy to generic combat You can add new enemies to the generic combat by adding your enemy object to the list. There are four lists for enemies: enemies_normal enemies_elite enemies_boss enemies_elite_boss They differ by encounter chance. The stronger the player the closer the chances are to being equal. enemies_normal.append(My_Enemy()) Create/Change lootlist and droplist Lootlist contains only cards . Droplist contains only items . To create your lootlist you need to add your lootlist: loot to the lootlist dictionary. my_lootlist = { # Replace existing lootlist \"werewolf\": [My_Card(), ...], # New lootlist \"my_loot\": [Aharon(), My_Card2(), ...] } # Add & replace lootlist found in my_lootlist for x in my_lootlist: lootlist.update({x: my_lootlist[x]}) Above code adds your lootlist to the game and replaces the ones in game with your replacements","title":"Enemies"},{"location":"enemies/#enemies","text":"","title":"Enemies"},{"location":"enemies/#create-new-enemy","text":"class Werewolf(Enemy): def __init__(self, name = \"Werewolf\", hp = 180, hp_max = 180, po = 1, race = \"Beast\", poU = 0, poL = 0, img = \"WerewolfA\", loot = \"werewolf\", faction = \"None\", act = 1, str = 0, agi = 0, vit = 0, inte = 0, cha = 0, wis = 0, drop = \"werewolf\"): self.name = name self.hp = hp self.hp_max = hp_max self.po = po # power self.race = race self.eff = copy.deepcopy(being.eff) # List of effect one can get in battle self.poU = poU # upper value of power difference ( set both poU and poL to 0 to delete random effects values ) self.poL = poL # lower value of power difference self.img = img # Name of enemy .webp inside Enemy folder self.loot = loot # Lootlist self.faction = faction # Enemy faction self.act = act # Action enemy would do in next turn self.drop = drop # your droplist # Cooldown for actions self.cd = { 1: 0, 2: 0, 3: 0, 4: 0 } # These are added for compatibility, they do nothing for now self.strength = str self.agility = agi self.vitality = vit self.wisdom = wis self.intellect = inte self.charisma = cha self.spirit_max = 0 def action(self, **kwargs): global enemy_state note = \"\" avoid = [] if self.eff['Stun'][0] > 0: self.eff['Stun'][0] -= 1 note = self.name + \" is stunned.\" self.end(note = note) return if self.act == 1: ### Basic Action enemy_state = \"attack\" self.atk(dmg = 14) note = \" slashes you!\" elif self.act == 2: ### 2nd Action self.heal(amt = 25) note = \"'s injuries heal quickly.\" self.cold(2) elif self.act == 3: enemy_state = \"attack\" self.atk(dmg = 6, times = 3) player.buff(\"Bleeding\", 3) note = \" quickly slashes you three times!\" self.cold(2) elif self.act == 4: enemy_state = \"specialA\" self.buff(\"Regeneration\", 4) self.buff(\"Strength\", 5) self.buff(\"Block\", 10) note = \" howls making it even more powerful!\" self.cold(3) if note != \"\": note = self.name + note if self.hp > (self.hp_max - 25): avoid.append(2) self.end(note = note, avoid = avoid) return def intent(self): back = self.name + \" wants to \" if self.act == 1: return back + \"attack.\" elif self.act == 2: if self.hp > (self.hp_max) - 25: return back + \"attack.\" else: return back + \"heal.\" elif self.act == 3: return back + \"rip you apart!\" elif self.act == 4: return back + \"empower itself.\" else: return \"Error 002 - Enemy action outside of possible action list.\"","title":"Create new enemy"},{"location":"enemies/#add-enemy-to-generic-combat","text":"You can add new enemies to the generic combat by adding your enemy object to the list. There are four lists for enemies: enemies_normal enemies_elite enemies_boss enemies_elite_boss They differ by encounter chance. The stronger the player the closer the chances are to being equal. enemies_normal.append(My_Enemy())","title":"Add enemy to generic combat"},{"location":"enemies/#createchange-lootlist-and-droplist","text":"Lootlist contains only cards . Droplist contains only items . To create your lootlist you need to add your lootlist: loot to the lootlist dictionary. my_lootlist = { # Replace existing lootlist \"werewolf\": [My_Card(), ...], # New lootlist \"my_loot\": [Aharon(), My_Card2(), ...] } # Add & replace lootlist found in my_lootlist for x in my_lootlist: lootlist.update({x: my_lootlist[x]}) Above code adds your lootlist to the game and replaces the ones in game with your replacements","title":"Create/Change lootlist and droplist"}]}